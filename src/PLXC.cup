import java_cup.runtime.*;

import java.util.List;
import java.util.ArrayList;
import java.util.Stack;
import java.util.Vector;

action code {:
    public void checkVariable(Objeto obj) {
        if (obj == null)
                      Objeto.errorYPara("[ERROR]\tLa variable no ha sido declarada", new Vector<>(List.of(obj)));

                  if (!(obj instanceof Instancia))
                      Objeto.errorYPara("[ERROR]\tLa variable no es una instancia", new Vector<>(List.of(obj)));
    }

    public void checkVariable(String id) {
        checkVariable(PLXC.tablaSimbolos.getObj(id));
    }

    public void checkType(Objeto obj, Tipo tipo) {
        if (!(obj instanceof Instancia))
            Objeto.errorYPara("[ERROR]\tNo se puede hacer una asignación si el valor a asignar no es una instancia", new Vector<>(List.of(obj, tipo)));
        Instancia aux = (Instancia) obj;
        if (!aux.getTipoInstancia().isParseable(tipo) )// || aux.getTipoInstancia().getClass() != tipo.getClass()
            Objeto.errorYPara("[ERROR]\tNo se puede hacer una asignación si el valor a asignar no es del mismo tipo o no son parseables entre sii", new Vector<>(List.of(obj, tipo)));
    }

    private String end_and = "", end_or = "";
    private Stack<String> if_tags = new Stack<>();
    private Objeto res_bool;
:}

parser code {:
    // Redefinition of error functions
    public void report_error(String message, Object info) {
        System.err.print("ERROR: Syntax error");
        if (info instanceof Symbol)
            if (((Symbol)info).left != -1){
                int line = (((Symbol)info).left);
                int column = (((Symbol)info).right);
                Symbol value = (Symbol)info;
                System.err.print(" (linea "+line+", colonna "+column+"): " + value.toString());
            } else System.err.print(": ");
        else System.err.print(": ");
    }
:}

terminal String ALL, CLL, AP, CP, AC, CC, PYC, COMA;
terminal Tipo INT, FLOAT, CHAR, STRING, U_MINUS;
terminal String ID;
terminal Integer NUM_ENTERO;
terminal Float NUM_REAL;
terminal Integer CARACTER;
terminal String CADENA;
terminal Boolean FALSE, TRUE;
terminal String MAS, MENOS, POR, DIV, EQ, NEQ, LT, GT, LE, GE, AND, OR, NOT, ASIGNA;
terminal String IF, WHILE, FOR, DO, PRINT;
terminal String ELSE, ELSEIF;

nonterminal program, lista_sent, sent, sent_comp, sent_simpl, sent_if, sent_while, op_else, sent_do_while, sent_for, for_expr;
nonterminal String and_end, or_end, else_if;
nonterminal Objeto cond, Get_BoolInstance;
nonterminal Integer Init_Bloque;
nonterminal List<String> list_id;
nonterminal List<Integer> list_int, list_char;
nonterminal List<Float> list_float;
nonterminal Tipo tipo, declr;
nonterminal Objeto asig, expr;

precedence right        ASIGNA;
precedence  left        IF, ELSE, DO, WHILE, FOR, PRINT;
precedence  left        MAS, MENOS;
precedence  left        POR, DIV;
precedence  left        U_MINUS;
precedence  left        EQ, LE, GE;
precedence  left        NEQ, LT, GT;
precedence  left        NOT, AND, OR;
precedence  left        ID, NUM_ENTERO, NUM_REAL;
precedence  left        FALSE, TRUE, CARACTER;
precedence  left        ELSEIF;

precedence  nonassoc    AP, CP;
precedence  nonassoc    AC, CC;
precedence  nonassoc    ALL, CLL;


start with program;

program ::= lista_sent;

lista_sent ::= sent
            | lista_sent sent
            ;

sent ::= sent_comp
        | sent_simpl ;

sent_comp ::= ALL Init_Bloque:bloquePrevio lista_sent CLL {:
                          PLXC.tablaSimbolos.delBlock();
                          TablaSimbolos.bloqueActual = bloquePrevio;
                      :};

sent_simpl ::= expr PYC
        | declr PYC
        | PRINT AP expr:valor CP PYC        {:  if (valor != null) RESULT = valor.metodos("PRINT", new Vector());   :}
        | sent_if
        | sent_while
        | sent_do_while
        | sent_for;

sent_while ::= WHILE:whileTag
                    // WHILE
                    {:
                    PLXC.out.println(whileTag + ":");
                    :}
                    AP cond:c CP
                    // if c == 0 goto end_while ;
                    {:
                    PLXC.out.println("if (" + c.getNombre() + " == 0) goto end_" + whileTag + ";");
                    :}
                    sent
                    // goto WHILE ;
                    // end_while:
                    {:
                    PLXC.out.println("goto " + whileTag + ";");
                       PLXC.out.println("end_" + whileTag + " :");:}
                    ;

sent_do_while ::= DO:doTag // -> Inicio y final del bucle
                    //DOWHILE:
                    {:
                    PLXC.out.println("DO_" + doTag + ":");
                    :}
                     sent
                    WHILE:whileTag AP cond:c CP PYC// -> Inicio de la condicion de parada
                    {:
                        PLXC.out.println("if (" + c.getNombre() + " == 1) goto DO_" + doTag + " ;");
                        PLXC.out.println("END_DO_" + doTag + ":");
                    :}
                    // END_DOWHILE
                    ;

for_expr ::= expr:expr
            |
            ;

sent_for ::= FOR:forTag AP for_expr:inic
            // init...
            // FOR:
            {:
                PLXC.out.println(forTag + ":");
            :}
            PYC cond:c
            // if (c == 0) goto FOR_END ;
            // goto FOR_BODY ;
            // FOR_ACT:
            {:
                PLXC.out.println("if (" + c.getNombre() + " == 0) goto end_" + forTag + ";");
                PLXC.out.println("goto body_" + forTag + ";");
                PLXC.out.println("act_" + forTag + ":");
            :}
            PYC for_expr:act
            // goto FOR ;
            {:
                PLXC.out.println("goto " + forTag + ";");
            :}
            CP
            // FOR_BODY :
            {:
                PLXC.out.println("body_" + forTag + ":");
            :}
            sent
            {:
                PLXC.out.println("goto act_" + forTag + ";");
                PLXC.out.println("end_" + forTag + ":");
            :}
            // goto FOR_ACT ;
            // FOR_END:
            ;

sent_if ::= IF:ifTag AP cond:c CP       {:
    this.if_tags.push(ifTag);
    PLXC.out.println("if (" + c.getNombre() + " == 0) goto else_" + ifTag + " ;");
:}
            sent                        {:
            PLXC.out.println("goto end_" + ifTag + " ;");
            PLXC.out.println("else_" + ifTag + ":");
:}
            else_if                     {:
            PLXC.out.println("end_" + ifTag + ":");
            this.if_tags.pop();
:};

else_if ::= ELSEIF:elseIfTag AP cond:c CP           {:
    PLXC.out.println(" if (" + c.getNombre() + " == 0) goto else_" + elseIfTag + ";");
:}
                sent                                {:
                PLXC.out.println("goto end_" + this.if_tags.peek() + ";");
                PLXC.out.println("else_" + elseIfTag + ":");
                :}
                else_if
            | ELSE sent
            |
            ;

declr ::= tipo:tipo ID:id                           {:
        Instancia newVar = new Instancia(id, tipo, TablaSimbolos.bloqueActual, true);
        PLXC.tablaSimbolos.putObj(newVar);

        RESULT = tipo;
:}
        | tipo:tipo ID:id AC expr:tam CC      {:
        Instancia newVar = new Instancia(id, new TArray(tipo, tam), TablaSimbolos.bloqueActual, true);
        PLXC.tablaSimbolos.putObj(newVar);

        RESULT = tipo;
        :}
        | declr:tipo COMA ID:id                     {:
        Instancia newVar = new Instancia(id, tipo, TablaSimbolos.bloqueActual, true);
        PLXC.tablaSimbolos.putObj(newVar);

        RESULT = tipo;
:}
        | tipo:tipo ID:id ASIGNA expr:exp           {:
            Instancia newVar = new Instancia(id, tipo, TablaSimbolos.bloqueActual, true);
            PLXC.tablaSimbolos.putObj(newVar);
            newVar.metodos("ASIGNA",new Vector<>(List.of(exp)));

            RESULT = tipo;
        :}
        | tipo:tipo ID:id AC expr:tam CC ASIGNA expr:exp {:
            Instancia newVar = new Instancia(id, new TArray(tipo, tam), TablaSimbolos.bloqueActual, true);
            PLXC.tablaSimbolos.putObj(newVar);

            newVar.metodos("ASIGNA",new Vector<>(List.of(exp)));

            RESULT = tipo;
        :}
        | declr:tipo COMA ID:id ASIGNA expr:exp     {:
            Instancia newVar = new Instancia(id, tipo, TablaSimbolos.bloqueActual, true);
            PLXC.tablaSimbolos.putObj(newVar);
            newVar.metodos("ASIGNA",new Vector<>(List.of(exp)));

            RESULT = tipo;
        :}
        ;

list_id ::=  ID:id                          {:
            List<String> start = new ArrayList<>();
            start.add(id);
            RESULT = start; :}
         | list_id:list COMA ID:id          {:  list.add(id); RESULT = list;        :};

list_char ::= list_char:list COMA CARACTER:c        {:  list.add(c); RESULT = list;        :}
           | CARACTER:c                             {:  List<Integer> start = new ArrayList<>();
                                                  start.add(c);
                                                  RESULT = start; :}
           ;

list_int ::= list_int:list COMA NUM_ENTERO:num      {:  list.add(num); RESULT = list;        :}
           | NUM_ENTERO:num                         {:  List<Integer> start = new ArrayList<>();
                                                  start.add(num);
                                                  RESULT = start; :}
          ;

list_float ::= list_float:list COMA NUM_REAL:num    {:
             list.add(num); RESULT = list;
:}
             | NUM_REAL:num                         {:
             List<Float> start = new ArrayList<>();
             start.add(num);
             RESULT = start;
:}
            ;

expr ::= AP expr:exp CP             {:  RESULT = exp;   :}
        | ID:id AC expr:idx CC ASIGNA expr:valor      {:
            // Checkear que el valor es una instancia y no es de tipo array
            checkVariable(id);
            // Checkear que le valor es del mismo que la variable
            Instancia variable = (Instancia) PLXC.tablaSimbolos.getObj(id);

            if (!(variable.getTipoInstancia() instanceof TArray))
                Objeto.errorYPara("[ERROR]\tLa variable no es un array", new Vector<>(List.of(variable)));

            RESULT = variable.metodos("SET", new Vector<>(List.of(idx, valor)));
        :}
        | ID:id ASIGNA expr:valor   {:
                  this.checkVariable(id); // Comprueba que la variable este declarada y que sea una instancia
                  Instancia variable = (Instancia) PLXC.tablaSimbolos.getObj(id);

                  if (!(variable.getTipoInstancia() instanceof TArray)) {
                        this.checkType(valor, variable.getTipoInstancia()); // Comprueba que el tipo de la variable sea el mismo que el de la expresion o sean parseables entre sii
                  }

                  RESULT = variable.metodos("ASIGNA", new Vector<>(List.of(valor)));
              :}
        | expr:a MAS:op expr:b      {:  RESULT = a.metodos(op, new Vector(List.of(b)));     :}
        | expr:a MENOS:op expr:b    {:  RESULT = a.metodos(op, new Vector(List.of(b)));     :}
        | expr:a POR:op expr:b      {:  RESULT = a.metodos(op, new Vector(List.of(b)));     :}
        | expr:a DIV:op expr:b      {:  RESULT = a.metodos(op, new Vector(List.of(b)));     :}
        | MENOS:op expr:exp         {:  RESULT = exp.metodos("UMENOS", new Vector());       :}   %prec U_MINUS
        | AP tipo:tipoDst CP expr:exp       {:

        if (exp instanceof Instancia) {
            Instancia aux = ((Instancia)exp).getTipoInstancia().cast(tipoDst, (Instancia) exp);
            if (aux != null) {
                RESULT = aux;
            } else {
                Objeto.errorYPara("[ERROR]\tNo se puede hacer una asignación si el valor a asignar no es del mismo tipo o no son parseables entre sii", new Vector<>());
            }
        } else {
            Objeto.errorYPara("[ERROR]\tNo se puede hacer un casting si el valor a asignar no es una instancia", new Vector<>());
        }

        :}
        | ID:id                     {:  checkVariable(id); RESULT = PLXC.tablaSimbolos.getObj(id);  :}
        | ID:id AC expr:idx CC        {:
            checkVariable(id);
            Instancia variable = (Instancia) PLXC.tablaSimbolos.getObj(id);

            if (!(variable.getTipoInstancia() instanceof TArray))
                Objeto.errorYPara("[ERROR]\tLa variable no es un array", new Vector<>(List.of(variable)));

            RESULT = variable.metodos("GET", new Vector<>(List.of(idx)));

        :}
        | ALL list_float:l CLL      {:
            Instancia res = new Instancia(new TArray(TFloat.getTFloat(), String.valueOf(l.size())));
            for (int i = 0; i < l.size(); i++) {
                PLXC.out.println(res.getNombre() + "[" + i + "] = " + l.get(i) + ";");
            }

            RESULT = res;
        :}
        | ALL list_int:l CLL        {:
            Instancia res = new Instancia(new TArray(TInt.getTInt(), String.valueOf(l.size())));
            for (int i = 0; i < l.size(); i++) {
                PLXC.out.println(res.getNombre() + "[" + i + "] = " + l.get(i) + ";");
            }

            RESULT = res;
        :}
        | ALL list_char:l CLL       {:
            Instancia res = new Instancia(new TArray(TChar.getTChar(), String.valueOf(l.size())));
            for (int i = 0; i < l.size(); i++) {
                PLXC.out.println(res.getNombre() + "[" + i + "] = " + l.get(i) + ";");
            }

            RESULT = res;
        :}
        | NUM_ENTERO:num            {:
        RESULT = new Instancia(num.toString(), TInt.getTInt(), TablaSimbolos.bloqueActual, false);
        :}
        | NUM_REAL:num              {:
        RESULT = new Instancia(num.toString(), TFloat.getTFloat(), TablaSimbolos.bloqueActual, false);
        :}
        | CARACTER:c                {:
        RESULT = new Instancia(c.toString(), TChar.getTChar(), TablaSimbolos.bloqueActual, false);
        :}
        | CADENA:s                  {:
        RESULT = new Instancia(s, TString.getInstance(), TablaSimbolos.bloqueActual, false);
        :}
        ;

cond ::=  AP cond:a CP          {:  RESULT = a;     :}
        | NOT cond:a            {:  RESULT = a.metodos("NOT", new Vector());   :}
        | cond:a  AND              {:
        this.end_and = PLXC.tablaSimbolos.getNewEtiq();
        this.res_bool = new Instancia(TBool.getTBool());
        PLXC.out.println(res_bool.getNombre() + " = " + a.getNombre() + ";");
        PLXC.out.println("if (" + a.getNombre() + " == 0) goto " + end_and + ";");
:}
            cond:b          {:
            PLXC.out.println(res_bool.getNombre() + " = " + b.getNombre() + ";");
            PLXC.out.println(this.end_and + ":");
            RESULT = res_bool;
:}
        | cond:a  OR               {:
        this.end_or = PLXC.tablaSimbolos.getNewEtiq();
        this.res_bool = new Instancia(TBool.getTBool());
        PLXC.out.println(res_bool.getNombre() + " = " + a.getNombre() + ";");
        PLXC.out.println("if (" + a.getNombre() + " == 1) goto " + end_or + ";");
:}
            cond:b           {:
            PLXC.out.println(res_bool.getNombre() + " = " + b.getNombre() + ";");
            PLXC.out.println(this.end_or + ":");
            RESULT = res_bool;
:}
        | expr:a GT expr:b      {:  RESULT = a.metodos("MAYOR", new Vector(List.of(b)));          :}
        | expr:a LT expr:b      {:  RESULT = a.metodos("MENOR", new Vector(List.of(b)));          :}
        | expr:a GE expr:b      {:  RESULT = a.metodos("MAYOR_IGUAL", new Vector(List.of(b)));    :}
        | expr:a LE expr:b      {:  RESULT = a.metodos("MENOR_IGUAL", new Vector(List.of(b)));    :}
        | expr:a EQ expr:b      {:  RESULT = a.metodos("IGUAL", new Vector(List.of(b)));          :}
        | expr:a NEQ expr:b     {:  RESULT = a.metodos("DISTINTO", new Vector(List.of(b)));       :}
        | FALSE                 {:  RESULT = new Instancia("0", TBool.getTBool(), TablaSimbolos.bloqueActual, false);   :}
        | TRUE                  {:  RESULT = new Instancia("1", TBool.getTBool(), TablaSimbolos.bloqueActual, false);    :}
        ;

tipo ::= INT:t          {:    RESULT = TInt.getTInt();            :}
        | FLOAT:t       {:    RESULT = TFloat.getTFloat();        :}
        | CHAR:t        {:    RESULT = TChar.getTChar();          :}
        | STRING:t      {:    RESULT = TString.getInstance();     :}
        |               {:    RESULT = TInt.getTInt();            :}
        ;

Init_Bloque ::=  {:  RESULT = TablaSimbolos.newBloque();     :};

and_end ::= {:  RESULT = PLXC.tablaSimbolos.getNewEtiq();     :};

or_end ::= {:  RESULT = PLXC.tablaSimbolos.getNewEtiq();     :};

Get_BoolInstance ::= {: RESULT = new Instancia(TBool.getTBool());:};

